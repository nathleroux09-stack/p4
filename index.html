<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<title>Puissance 4 Matchmaking</title>
<style>
:root{
  --bg:#071128; --card:#0e2436; --muted:#9fb7c7; --text:#e8f3fb;
  --accent:#2ea44f; --accent-strong:#26a14a; --ghost:#133147; --danger:#e06a4a;
  --board-hole:#0b3a57; --hole-edge:#163a54; --disc-shadow: rgba(0,0,0,0.45);
}
*{box-sizing:border-box}
html,body{height:100%;}
body{margin:0;padding:0.9rem;font-family:-apple-system, "Inter", "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
background:linear-gradient(180deg,var(--bg) 0%, #052033 100%); color:var(--text);
display:flex;flex-direction:column;align-items:center;justify-content:flex-start;gap:0.8rem;min-height:100vh;}
h1{margin:0.6rem 0 0;font-size:1.15rem;font-weight:700;color:var(--text);letter-spacing:0.2px;text-align:center;width:100%;max-width:420px;text-shadow:0 1px 0 rgba(0,0,0,0.45);padding:8px 0;}
#loginContainer, #controls, #rematchContainer, #clocks, #playerInfo{width:100%;max-width:420px;display:flex;flex-direction:column;gap:0.45rem;align-items:stretch;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.02));padding:0.7rem;border-radius:12px;border:1px solid rgba(255,255,255,0.04);box-shadow:0 6px 18px rgba(2,6,12,0.55), inset 0 1px 0 rgba(255,255,255,0.02);}
input[type="text"], input[type="password"], textarea{width:100%;min-height:44px;padding:10px 12px;border-radius:10px;border:1px solid rgba(255,255,255,0.06);background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.03));color:var(--text);font-size:0.95rem;outline:none;box-shadow:inset 0 1px 0 rgba(255,255,255,0.02);resize: vertical;transition: box-shadow .12s ease, border-color .12s ease, transform .06s ease;}
input::placeholder{color: rgba(255,255,255,0.35); font-weight:500;}
input:focus, textarea:focus{border-color: rgba(46,164,79,0.9);box-shadow:0 6px 18px rgba(46,164,79,0.06), inset 0 1px 0 rgba(255,255,255,0.02);transform: translateY(-1px);}
button{display:inline-flex;align-items:center;justify-content:center;gap:8px;min-height:44px;padding:10px 14px;border-radius:12px;border:none;background:var(--ghost);color:var(--text);font-weight:700;font-size:0.95rem;cursor:pointer;transition: transform .08s ease, box-shadow .12s ease, background .12s ease;box-shadow:0 6px 14px rgba(2,6,12,0.5);}
#loginContainer button#loginBtn,#loginContainer button#createAccountBtn,#controls button#joinMatch,#rematchContainer button#rematchBtn{background:linear-gradient(180deg, var(--accent), var(--accent-strong)); color:#fff; box-shadow:0 8px 22px rgba(38,161,74,0.18);}
button:hover{ transform: translateY(-2px); } button:active{ transform: translateY(0); box-shadow:0 4px 8px rgba(0,0,0,0.5); } button:disabled{opacity:0.45;cursor:not-allowed;transform:none;box-shadow:none;}
#status,#loginStatus,#rematchStatus{color:var(--muted);font-weight:600;font-size:0.9rem;padding:6px 8px;border-radius:8px;background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(0,0,0,0.02));border:1px solid rgba(255,255,255,0.02);}
#playerInfo{display:flex;gap:12px;align-items:center;justify-content:space-between;padding:8px;background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(0,0,0,0.02));}
#playerInfo > div{display:flex;flex-direction:column;gap:4px;font-size:0.95rem;color:var(--text);}
#playerInfo span{ font-weight:800;color:#fff;font-size:0.95rem;}
#clocks{display:flex;gap:12px;align-items:center;justify-content:space-between;padding:8px 10px;border-radius:10px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.03));border:1px solid rgba(255,255,255,0.03);font-weight:800;font-size:0.95rem;}
#board{width:100%;max-width:420px;aspect-ratio:7/6;display:grid;grid-template-columns:repeat(7,1fr);grid-template-rows:repeat(6,1fr);gap:8px;padding:14px;border-radius:16px;background:linear-gradient(180deg,var(--board-hole),#082a3d);box-shadow:0 18px 40px rgba(1,8,15,0.7), inset 0 2px 10px rgba(255,255,255,0.02);touch-action:manipulation;}
.cell{width:100%;height:100%;aspect-ratio:1/1;border-radius:50%;display:flex;align-items:center;justify-content:center;background: radial-gradient(circle at 30% 25%, rgba(255,255,255,0.03), transparent 20%), linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.03));box-shadow: inset 0 -6px 12px rgba(0,0,0,0.6), inset 0 2px 6px rgba(255,255,255,0.02);cursor:pointer;transition: transform .08s ease;position:relative;overflow:hidden;border:1px solid rgba(255,255,255,0.02);}
.cell:active{transform: translateY(1px) scale(.997);}
.disc{width:86%;height:86%;border-radius:50%;background:#111;box-shadow:0 6px 14px var(--disc-shadow), inset 0 2px 8px rgba(255,255,255,0.03);transition: transform .28s cubic-bezier(.2,.9,.3,1), background .2s ease, box-shadow .12s ease;display:block;z-index:1;}
.cell::after{content:"";position:absolute;inset:10% 10%;border-radius:50%;background: radial-gradient(circle at 35% 30%, rgba(255,255,255,0.02), rgba(0,0,0,0.3));z-index:0;pointer-events:none;}
.disc.red{background: linear-gradient(180deg,#ff5b5b,#c43b3b);box-shadow:0 8px 18px rgba(196,59,59,0.28), inset 0 2px 8px rgba(255,255,255,0.06);}
.disc.yellow{background: linear-gradient(180deg,#ffd35b,#d6a42c);box-shadow:0 8px 18px rgba(214,164,44,0.22), inset 0 2px 8px rgba(255,255,255,0.06);}
@keyframes dropIn{from{transform:translateY(-40%) scale(.98);opacity:0.85;}to{transform:translateY(0) scale(1);opacity:1;}}
.disc.dropped{animation: dropIn .26s cubic-bezier(.2,.9,.3,1) both;}
#rematchContainer{display:flex;gap:8px;align-items:center;justify-content:center;padding:8px;background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(0,0,0,0.02));border-radius:12px;}
</style>
</head>
<body>
<h1>Puissance 4 Matchmaking</h1>

<div id="loginContainer">
  <input type="text" id="usernameInput" placeholder="Pseudo">
  <input type="password" id="passwordInput" placeholder="Mot de passe">
  <button id="createAccountBtn">Créer un compte</button>
  <button id="loginBtn">Se connecter</button>
  <div id="loginStatus"></div>
</div>

<div id="playerInfo" style="display:none;">
  <div id="myEloContainer">Elo : <span id="myElo"></span></div>
</div>

<div id="controls" style="display:none;">
  <button id="joinMatch">Chercher adversaire</button>
  <div id="status">Statut : Déconnecté</div>
</div>

<div id="clocks" style="display:none;">
  <div id="myClockContainer"><span id="myPseudo"></span> (<span id="myEloClock"></span>) : <span id="myClock">05:00</span></div>
  <div id="opClockContainer"><span id="opPseudo"></span> (<span id="opEloClock"></span>) : <span id="opClock">05:00</span></div>
</div>

<div id="board"></div>

<div id="rematchContainer">
  <button id="rematchBtn">Revanche</button>
  <button id="declineBtn">✖</button>
  <span id="rematchStatus"></span>
</div>

<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/dist/supabase.min.js"></script>
<script type="module">
import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm';
const SUPABASE_URL = 'https://arqyrmvnenrtxqryihnz.supabase.co';
const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImFycXlybXZuZW5ydHhxcnlpaG56Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjE3NTE1NjUsImV4cCI6MjA3NzMyNzU2NX0.fGs08ElwvYY2JOnWmq4sveYEa2Dg7g0BsdmRrkRM4xc';
const supabase = createClient(SUPABASE_URL, SUPABASE_KEY);

const el = id => document.getElementById(id);

let board = Array(6).fill().map(()=>Array(7).fill(''));
let turn = null, myColor = null, opponentColor = null, gameOver = false;
let myTime = 300, opTime = 300, myInterval = null, opInterval = null;
let currentUser = null, currentMatch = null, firstMovePlayed = false;
let realtimeChannel = null;

// ---------- UTIL ----------
function formatTime(t){ const min = String(Math.floor(t/60)).padStart(2,'0'); const sec = String(t%60).padStart(2,'0'); return `${min}:${sec}`; }

function resetLocalTimers(){
  clearInterval(myInterval); clearInterval(opInterval);
  myInterval = null; opInterval = null;
  myTime = 300; opTime = 300;
  if(el('myClock')) el('myClock').textContent = formatTime(myTime);
  if(el('opClock')) el('opClock').textContent = formatTime(opTime);
}

function resetBoardLocal(){
  board = Array(6).fill().map(()=>Array(7).fill(''));
  updateBoard();
}

function hidePseudosAndClocksAndShowMatchmaking(){
  el('playerInfo').style.display = 'none';
  el('clocks').style.display = 'none';
  el('controls').style.display = 'flex';
}

function resetAfterMatchDeletion(){
  gameOver = false;
  turn = null;
  myColor = null;
  opponentColor = null;
  firstMovePlayed = false;
  resetLocalTimers();
  resetBoardLocal();
  currentMatch = null;
  if(realtimeChannel){
    try{ realtimeChannel.unsubscribe(); }catch(e){}
    realtimeChannel = null;
  }
  hidePseudosAndClocksAndShowMatchmaking();
  el('status').textContent = 'Statut : Déconnecté';
}

// ---------- BOARD ----------
function createBoard(){
  const boardDiv = el('board'); boardDiv.innerHTML='';
  for(let r=0;r<6;r++){
    for(let c=0;c<7;c++){
      const cell = document.createElement('div'); cell.className='cell'; cell.dataset.col=c;
      const disc = document.createElement('div'); disc.className='disc'; cell.appendChild(disc);
      cell.onclick = ()=>handleColumnClick(c);
      boardDiv.appendChild(cell);
    }
  }
}
createBoard();

function updateBoard(){
  const discs = document.querySelectorAll('.disc');
  for(let r=0;r<6;r++){
    for(let c=0;c<7;c++){
      const idx = r*7 + c;
      if(board[r][c]==='red') discs[idx].className='disc red dropped';
      else if(board[r][c]==='yellow') discs[idx].className='disc yellow dropped';
      else discs[idx].className='disc';
    }
  }
}

// retourne true si posé, false si colonne pleine
async function dropDisc(col,color){
  for(let r=5;r>=0;r--){
    if(!board[r][col]){
      board[r][col] = color;
      updateBoard();

      // si premier coup de la partie -> activer la logique de pendules (les intervals démarrent seulement après)
      if(!firstMovePlayed){
        firstMovePlayed = true;
      }

      // vérifie victoire
if (checkWin(r, col, color)) {
  // Déterminer pseudo du gagnant
  let winnerPseudo = (currentUser && color === myColor)
    ? currentUser.username
    : getOpponentPseudo();
  if (!winnerPseudo) winnerPseudo = color === 'red' ? 'Red' : 'Yellow';

  // Afficher immédiatement localement
  el('status').textContent = `${winnerPseudo} a gagné !`;
  gameOver = true;

  // Stop les pendules et réinitialise visuellement
  resetLocalTimers();
  if (el('myClock')) el('myClock').textContent = formatTime(300);
  if (el('opClock')) el('opClock').textContent = formatTime(300);

  // Cacher les éléments inutiles pendant la fin de partie
  el('playerInfo').style.display = 'none';
  el('clocks').style.display = 'none';
  el('controls').style.display = 'flex';

  // ⚙️ Mise à jour atomique : board final + statut + gagnant + blocage des tours
  try {
    await supabase.from('matches').update({
      boardstate: JSON.stringify(board),
      status: 'finished',
      winner: winnerPseudo,
      turn: null // empêche tout coup supplémentaire
    }).eq('id', currentMatch.id);
  } catch (err) {
    console.error('Erreur enregistrement finish:', err);
  }

  // ⏳ Attendre la propagation avant suppression du match
  setTimeout(async () => {
    try {
      await supabase.from('matches').delete().eq('id', currentMatch.id);
      resetAfterMatchDeletion();
    } catch (err) {
      console.error('Erreur suppression match:', err);
    }
  }, 5000);

  return;
}

        // Supprimer ensuite la ligne après 5s (donner le temps à la subscription de propager l'UPDATE)
        setTimeout(async () => {
          try{
            await supabase.from('matches').delete().eq('id', currentMatch.id);
          }catch(err){
            console.error('Erreur suppression match:', err);
            // si delete échoue, on reset localement quand même
            resetAfterMatchDeletion();
          }
        }, 5000);

      } else {
        // Coup normal : envoyer boardstate + nouveau tour de manière atomique
        try{
          await supabase.from('matches').update({
            boardstate: JSON.stringify(board),
            turn: (color === 'red' ? 'yellow' : 'red')
          }).eq('id', currentMatch.id);
        }catch(err){
          console.error('Erreur update move:', err);
        }
      }

      return true;
    }
  }
  return false;
}

function checkWin(row,col,color){
  const dirs = [[1,0],[0,1],[1,1],[1,-1]];
  const countDir = (dr,dc)=>{
    let r = row + dr, c = col + dc, cnt = 0;
    while(r>=0 && r<6 && c>=0 && c<7 && board[r][c] === color){ cnt++; r += dr; c += dc; }
    return cnt;
  };
  for(const [dr,dc] of dirs){
    if(1 + countDir(dr,dc) + countDir(-dr,-dc) >= 4) return true;
  }
  return false;
}

// ---------- LOGIN / CREATE ----------
el('createAccountBtn').onclick = async () => {
  const username = el('usernameInput').value.trim(), password = el('passwordInput').value.trim();
  if(!username || !password){ el('loginStatus').textContent = "Pseudo et mdp requis"; return; }
  const { data, error } = await supabase.from('profiles').insert([{ username, password, elo:1000 }]);
  if(error){ el('loginStatus').textContent = "Erreur création compte: " + error.message; return; }
  el('loginStatus').textContent = "Compte créé, connecte-toi";
};

el('loginBtn').onclick = async () => {
  const username = el('usernameInput').value.trim(), password = el('passwordInput').value.trim();
  if(!username || !password){ el('loginStatus').textContent = "Pseudo et mdp requis"; return; }
  const { data, error } = await supabase.from('profiles').select('*').eq('username', username).eq('password', password).single();
  if(error || !data){ el('loginStatus').textContent = "Pseudo ou mdp incorrect"; return; }
  currentUser = { username: data.username, elo: parseInt(data.elo) };
  el('myElo').textContent = currentUser.elo;
  el('loginContainer').style.display = 'none';
  el('controls').style.display = 'flex';
  el('playerInfo').style.display = 'flex';
  el('myPseudo').textContent = currentUser.username;
  el('myEloClock').textContent = currentUser.elo;
  el('status').textContent = 'Statut : Disponible';
  resetLocalTimers();
};

// ---------- MATCHMAKING ----------
el('joinMatch').onclick = async () => {
  if(!currentUser){ el('status').textContent = 'Connecte-toi d\'abord'; return; }

  el('status').textContent = "Statut : Recherche adversaire...";

  // Cherche un match waiting qui n'est pas créé par moi
  const { data: waitingMatch, error: errWait } = await supabase
    .from('matches')
    .select('*')
    .eq('status', 'waiting')
    .neq('player1', currentUser.username)
    .limit(1)
    .single();

  if(errWait && errWait.code !== 'PGRST116'){ console.error('errWait', errWait); el('status').textContent = 'Erreur matchmaking'; return; }

  if(waitingMatch && waitingMatch.id){
    // Rejoindre match existant
    currentMatch = waitingMatch;
    myColor = 'yellow';
    opponentColor = 'red';
    try{
      await supabase.from('matches').update({
        player2: currentUser.username,
        p2_elo: currentUser.elo,
        turn: 'red',
        status: 'playing',
        boardstate: JSON.stringify(board)
      }).eq('id', currentMatch.id);
    }catch(e){ console.error('Erreur join update', e); }
  } else {
    // Créer match
    try{
      const { data: newMatch, error } = await supabase.from('matches').insert([{
        player1: currentUser.username,
        p1_elo: currentUser.elo,
        status: 'waiting',
        boardstate: JSON.stringify(board),
        turn: 'red'
      }]).select().single();
      if(error){ console.error('Erreur insert match', error); el('status').textContent = 'Erreur création match'; return; }
      currentMatch = newMatch;
      myColor = 'red';
      opponentColor = 'yellow';
    }catch(e){ console.error('Erreur insert', e); return; }
  }

  // UI
  el('controls').style.display = 'none';
  el('clocks').style.display = 'flex';
  el('playerInfo').style.display = 'flex';
  el('status').textContent = "Statut : Match trouvé !";

  // Afficher adversaire si déjà présent
  if(currentMatch){
    el('opPseudo').textContent = currentMatch.player1 === currentUser.username ? currentMatch.player2 : currentMatch.player1;
    el('opEloClock').textContent = currentMatch.player1 === currentUser.username ? currentMatch.p2_elo : currentMatch.p1_elo;
  }

  resetLocalTimers();
  startListeningMatch();
  updateClocks();
};

// ---------- SUBSCRIPTION ----------
function startListeningMatch(){
  if(realtimeChannel){
    try{ realtimeChannel.unsubscribe(); }catch(e){}
    realtimeChannel = null;
  }
  if(!currentMatch || !currentMatch.id) return;

  realtimeChannel = supabase
    .channel('realtime-matches-' + currentMatch.id)
    .on('postgres_changes', { event: '*', schema: 'public', table: 'matches', filter: `id=eq.${currentMatch.id}` }, payload => {
      // payload.new (insert/update) or payload.old (delete)
      if(!payload) return;

      const isDelete = (!payload.new && payload.old);
      if(isDelete){
        // match supprimé -> réinitialiser l'UI
        resetAfterMatchDeletion();
        return;
      }

      const updated = payload.new;
      if(!updated) return;

      // MAJ board si présent (important: on applique boardstate AVANT l'event finished pour afficher le dernier jeton)
      try{ if(updated.boardstate) board = JSON.parse(updated.boardstate); }catch(e){ console.warn('board parse err', e); }

      // MAJ currentMatch fields safely
      currentMatch.player1 = updated.player1 ?? currentMatch.player1;
      currentMatch.player2 = updated.player2 ?? currentMatch.player2;
      currentMatch.p1_elo = updated.p1_elo ?? currentMatch.p1_elo;
      currentMatch.p2_elo = updated.p2_elo ?? currentMatch.p2_elo;
      currentMatch.turn = updated.turn ?? currentMatch.turn;
      currentMatch.status = updated.status ?? currentMatch.status;
      currentMatch.winner = updated.winner ?? currentMatch.winner;

      // MAJ local turn
      turn = updated.turn ?? turn;

      // Si partie finie (update) : bloquer localement, afficher message, reset pendules et UI
      if(updated.status === 'finished'){
        gameOver = true;
        clearInterval(myInterval); clearInterval(opInterval);
        myInterval = null; opInterval = null;
        myTime = 300; opTime = 300;
        if(el('myClock')) el('myClock').textContent = formatTime(300);
        if(el('opClock')) el('opClock').textContent = formatTime(300);

        // Afficher le message (winner stocké comme pseudo)
        if(updated.winner) el('status').textContent = `${updated.winner} a gagné !`;

        // Cacher pseudos & pendules et afficher matchmaking
        el('playerInfo').style.display = 'none';
        el('clocks').style.display = 'none';
        el('controls').style.display = 'flex';

        // La suppression (DELETE) sera effectuée par le client qui a initié la victoire après 5s.
      }

      updateBoard();
      updateClocks();
    }).subscribe();
}

// ---------- HANDLE COLUMN CLICK ----------
async function handleColumnClick(col){
  if(!currentMatch){ el('status').textContent = 'Pas de match actif'; return; }
  if (!turn || turn !== myColor || gameOver) return; // ne peut jouer que si c'est son tour
  if (!await dropDisc(col, myColor)) return;
  // si non-victoire, le dropDisc a déjà fait await de l'update move
  // si victoire, dropDisc a déjà fait await de l'update finish puis planifié le delete
}

// ---------- CLOCKS ----------
function updateClocks(){
  if(el('myClock')) el('myClock').textContent = formatTime(myTime);
  if(el('opClock')) el('opClock').textContent = formatTime(opTime);
  if(currentUser){
    el('myPseudo').textContent = currentUser.username;
    el('myEloClock').textContent = currentUser.elo;
  }
  if(currentMatch){
    const opPseudo = currentMatch.player1 === currentUser.username ? currentMatch.player2 : currentMatch.player1;
    const opElo = currentMatch.player1 === currentUser.username ? currentMatch.p2_elo : currentMatch.p1_elo;
    el('opPseudo').textContent = opPseudo ?? '';
    el('opEloClock').textContent = opElo ?? '';
  }

  // Ne pas démarrer les intervals avant le 1er coup ou si partie finie
  if(!firstMovePlayed || gameOver) return;

  if(turn === myColor){
    if(!myInterval) myInterval = setInterval(() => {
      myTime--;
      if(el('myClock')) el('myClock').textContent = formatTime(myTime);
      if(myTime <= 0){
        // perte par time -> l'autre gagne
        endGame(getOpponentPseudo() + ' a gagné !', opponentColor);
      }
    }, 1000);
    if(opInterval){ clearInterval(opInterval); opInterval = null; }
  } else {
    if(!opInterval) opInterval = setInterval(() => {
      opTime--;
      if(el('opClock')) el('opClock').textContent = formatTime(opTime);
      if(opTime <= 0){
        endGame(currentUser.username + ' a gagné !', myColor);
      }
    }, 1000);
    if(myInterval){ clearInterval(myInterval); myInterval = null; }
  }
}

// ---------- END GAME / HELPERS ----------
function getOpponentPseudo(){
  if(!currentMatch) return '';
  return currentMatch.player1 === currentUser.username ? currentMatch.player2 : currentMatch.player1;
}

function endGame(displayMsg, winnerColor){
  // usage: displayMsg peut être 'Paul a gagné !' ou on construit depuis winnerColor
  gameOver = true;
  clearInterval(myInterval); clearInterval(opInterval);
  myInterval = null; opInterval = null;

  // Remettre pendules à 5:00 affichage
  myTime = 300; opTime = 300;
  if(el('myClock')) el('myClock').textContent = formatTime(myTime);
  if(el('opClock')) el('opClock').textContent = formatTime(opTime);

  // Bloquer localement
  turn = null;

  // Afficher message
  if(displayMsg) el('status').textContent = displayMsg;
  else {
    const winnerPseudo = (winnerColor === myColor) ? currentUser.username : getOpponentPseudo();
    el('status').textContent = `${winnerPseudo} a gagné !`;
  }

  // Cacher pseudos & pendules & remettre matchmaking visible
  el('playerInfo').style.display = 'none';
  el('clocks').style.display = 'none';
  el('controls').style.display = 'flex';

  // Si match existant, écrire finished + winner (cela assure que l'autre client reçoit l'UPDATE si besoin)
  if(currentMatch && currentMatch.id){
    supabase.from('matches').update({
      status: 'finished',
      winner: (displayMsg ? displayMsg.replace(' a gagné !','') : (winnerColor === myColor ? currentUser.username : getOpponentPseudo())),
      boardstate: JSON.stringify(board)
    }).eq('id', currentMatch.id).catch(e => console.error('err endgame update', e));

    // delete après 5s
    setTimeout(async () => {
      try{
        await supabase.from('matches').delete().eq('id', currentMatch.id);
      }catch(e){
        console.error('err deleting after timeout', e);
        // si delete échoue -> reset local
        resetAfterMatchDeletion();
      }
    }, 5000);
  } else {
    setTimeout(() => resetAfterMatchDeletion(), 5000);
  }
}
</script>
</body>
</html>
